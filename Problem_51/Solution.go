package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
	"strconv"
)

// Analysis
// ========
// The problem requires us to find a prime number and a set of digits from the number such that,
// when you replace the digits, (at least) 8 of the resulting numbers are prime.
//
// I will assume that the digits from the original number must be the same, because the question
// implies that the original number belongs to the "family" of 8 generated primes.
//
// Instead of looking for prime numbers, let's iterate through all numbers and see if they generate
// a prime family. If the prime family doesn't contain the original number, we can just replace it
// with the smallest prime in the family. This allows us to restrict ourselves to looking at digits
// that are 0 or 1 - for example, we don't need to consider the 2 in 1123 because 1103 is
// considered earlier. The digit of interest will only be 1 if the number starts with a 1. (The
// number 3 can be written as 03, but it still only counts as a one-digit number).

// Just guessed these bounds and they happened to be sufficient.
const SieveSize = 2_000_000
const DigitIndicesArraySize = 64

// A prime number sieve, where the value at index i says whether i is prime. 0 and 1 are not prime.
type Sieve []bool

// Creates a Sieve of Erastothenes up to the given number. The sieve has length (max + 1) and
// records the primality of the numbers 0 to max.
func SieveOfErastothenes(max int) *Sieve {
	// Allocate sieve.
	sieve := Sieve(make([]bool, max+1))
	// Initialise values to true for i >= 2.
	for i := 2; i <= max; i++ {
		sieve[i] = true
	}
	// Set composite values to false.
	sqrtMax := int(math.Sqrt(float64(max)))
	for i := 2; i <= sqrtMax; i++ {
		if sieve[i] {
			for j := i * i; j <= max; j += i {
				sieve[j] = false
			}
		}
	}
	return &sieve
}

// Gets all the indices where the given digit appears in n. Assumes n is positive.
func GetIndicesOfDigit(n int, digit int) []int {
	res := [DigitIndicesArraySize]int{}
	resIndex := 0
	quot, rem := n, 0
	for nIndex := 0; quot > 0; nIndex++ {
		quot, rem = quot/10, quot%10
		if rem == digit {
			res[resIndex] = nIndex
			resIndex++
		}
	}
	return res[:resIndex]
}

// Returns an iterator for the non-empty subsets of the given set. Assumes that the set has
// at most 63 elements (on a 64-bit system).
func GetNonEmptySubsets(set []int) chan []int {
	ch := make(chan []int)
	go func() {
		// counterMax must be positive, so len(set) must be <= 63.
		counterMax := 1<<len(set) - 1
		// We start at counterMax and count down, to avoid overflow issues.
		// We exclude counter == 0 because we don't need the empty set.
		for counter := counterMax; counter > 0; counter-- {
			subset := make([]int, len(set))
			subsetIndex := 0
			for setIndex, item := range set {
				bitFlag := 1 << setIndex
				includeItem := (counter & bitFlag) != 0
				if includeItem {
					subset[subsetIndex] = item
					subsetIndex++
				}
			}
			ch <- subset[:subsetIndex]
		}
		close(ch)
	}()
	return ch
}

// Returns a decimal number with a 1 in each of the given indices and 0s everywhere else.
// This number can be added or subtracted from another number to modify all the digits at
// the given indices by the same amount. Assumes the indices are all at most 15.
func GetDigitModifier(indices []int) int {
	res := 0
	for _, index := range indices {
		// Integers up to 2^52 can be exactly represented as float64, so this should be accurate
		// as long as math.Round is accurate enough. 2^52 ~ 4.5*10^15, hence the limit of 15
		// decimal digits.
		res += int(math.Round(math.Pow10(index)))
	}
	return res
}

// Gets the leading decimal digit of n. Assumes n is positive.
func GetLeadingDigit(n int) int {
	quot, rem := n, 0
	for {
		quot, rem = quot/10, quot%10
		if quot == 0 {
			return rem
		}
	}
}

func ArithmeticProgression(start int, step int, count int) []int {
	res := make([]int, count)
	for i, x := 0, start; i < count; i, x = i+1, x+step {
		res[i] = x
	}
	return res
}

func CountPrimes(candidates []int, sieve *Sieve) int {
	count := 0
	for _, x := range candidates {
		if (*sieve)[x] {
			count++
		}
	}
	return count
}

func Max(x int, y int) int {
	if x >= y {
		return x
	}
	return y
}

// Gets the maximum size of a prime family generated by n, considering only those
// families generated by the digits that are 0 or 1.
func GetMaxPrimeFamilySize(n int, sieve *Sieve) int {
	maxFamilySize := 0
	zeroIndices := GetIndicesOfDigit(n, 0)
	zeroSubsets := GetNonEmptySubsets(zeroIndices)
	for subset := range zeroSubsets {
		modifier := GetDigitModifier(subset)
		candidates := ArithmeticProgression(n, modifier, 10)
		familySize := CountPrimes(candidates, sieve)
		maxFamilySize = Max(maxFamilySize, familySize)
	}
	if GetLeadingDigit(n) == 1 {
		oneIndices := GetIndicesOfDigit(n, 1)
		oneSubsets := GetNonEmptySubsets(oneIndices)
		for subset := range oneSubsets {
			modifier := GetDigitModifier(subset)
			candidates := ArithmeticProgression(n, modifier, 9)
			familySize := CountPrimes(candidates, sieve)
			maxFamilySize = Max(maxFamilySize, familySize)
		}
	}
	return maxFamilySize
}

func GetTargetFamilySize() int {
	if len(os.Args) >= 2 {
		fmt.Printf("Target family size (usually 8): %v\n", os.Args[1])
		familySize, err := strconv.ParseInt(os.Args[1], 10, 0)
		if err == nil {
			return int(familySize)
		}
		fmt.Println(err)
	}
	reader := bufio.NewReader(os.Stdin)
	for {
		fmt.Print("Target family size (usually 8): ")
		input, _ := reader.ReadString('\n')
		familySize, err := strconv.ParseInt(input, 10, 0)
		if err == nil {
			return int(familySize)
		}
		fmt.Println(err)
	}

}

func main() {
	targetFamilySize := GetTargetFamilySize()
	sieve := SieveOfErastothenes(SieveSize)
	for n := 1; ; n++ {
		familySize := GetMaxPrimeFamilySize(n, sieve)
		if familySize >= targetFamilySize {
			fmt.Printf("n = %v has family size %v\n", n, familySize)
			return
		}
	}
}
